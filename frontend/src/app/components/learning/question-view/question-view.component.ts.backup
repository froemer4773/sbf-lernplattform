import { Component, signal, computed, ChangeDetectionStrategy, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { ApiService } from '../../../services/api.service';
import { AuthService } from '../../../services/auth.service';
import { Question, SubmitAnswerRequest, QuestionProgress } from '../../../models/models';

@Component({
  selector: 'app-question-view',
  imports: [CommonModule],
  templateUrl: './question-view.component.html',
  styleUrl: './question-view.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class QuestionViewComponent {
  // Session / timing
  private sessionStart = Date.now();
  private questionStart = Date.now();
  private totalSessionSeconds = 0;
  private sessionId: number | string | null = null;
  private answeredCount = 0;

  questions = signal<Question[]>([]);
  currentQuestionIndex = signal<number>(0);
  selectedAnswers = signal<Map<number, string>>(new Map());
  incorrectAnswers = signal<Set<number>>(new Set());
  shuffledAnswers = signal<Map<number, any[]>>(new Map());
  answerResults = signal<Array<{frage_id: number, frage_text: string, selected_answer: string, correct_answer: string, is_correct: boolean}>>([]);
  bookmarkedQuestions = signal<Set<number>>(new Set()); // Gemerkte Fragen
  loading = signal<boolean>(true);
  error = signal<string | null>(null);
  schein = signal<string>('');
  kategorie = signal<string>('');
  unterkategorie = signal<string | null>(null);
  filter = signal<string | null>(null); // 'incorrect' oder 'bookmarked'
  showHint = signal<boolean>(false);
  revealed = signal<boolean>(false);

  currentQuestion = computed(() => {
    const questions = this.questions();
    const index = this.currentQuestionIndex();
    return index >= 0 && index < questions.length ? questions[index] : null;
  });

  currentShuffledAnswers = computed(() => {
    const question = this.currentQuestion();
    if (!question) return [];
    return this.shuffledAnswers().get(question.frage_id) || [];
  });

  progress = computed(() => {
    const total = this.questions().length;
    const current = this.currentQuestionIndex() + 1;
    return { current, total, percentage: total > 0 ? (current / total) * 100 : 0 };
  });

  isAuthenticated = computed(() => {
    return !!this.authService.getToken();
  });

  constructor(
    public apiService: ApiService,
    private authService: AuthService,
    private route: ActivatedRoute,
    private router: Router
  ) {
    this.route.params.subscribe(params => {
      const schein = params['schein'];
      const kategorie = params['kategorie'];
      if (schein && kategorie) {
        this.schein.set(schein);
        this.kategorie.set(kategorie);

        // Also check for unterkategorie and filter query parameters
        this.route.queryParams.subscribe(queryParams => {
          const unterkategorie = queryParams['unterkategorie'];
          const filter = queryParams['filter'];
          this.unterkategorie.set(unterkategorie || null);
          this.filter.set(filter || null);
          this.loadQuestions(schein, kategorie, unterkategorie, filter);
        });
      }
    });
  }

  // Ensure we send session data on destroy (best-effort)
  ngOnDestroy(): void {
    try {
      if (this.totalSessionSeconds > 0) {
        // If backend supports explicit session lifecycle, use it
        if (this.sessionId != null) {
          this.apiService.endSession(this.sessionId, this.totalSessionSeconds).subscribe({
            next: () => console.log('Session ended:', this.sessionId, this.totalSessionSeconds),
            error: (err) => console.warn('Session end failed (may be unsupported):', err)
          });
        } else {
          // Fallback: attempt to post a generic session end (server may accept without id)
          this.apiService.endSession(null, this.totalSessionSeconds).subscribe({
            next: () => console.log('Session logged (no id):', this.totalSessionSeconds),
            error: (err) => console.warn('Session logging failed (may be unsupported):', err)
          });
        }
      }
    } catch (e) {
      // ignore any errors
    }
  }

  onBack(event: Event) {
    event.preventDefault();
    this.endSessionAndNavigate('/learning/category-selection');
  }

  private endSessionAndNavigate(route: string) {
    const navigate = () => {
      try {
        this.router.navigate([route]);
      } catch (e) {
        console.warn('Navigation failed:', e);
      }
    };

    if (this.totalSessionSeconds > 0 && this.sessionId != null) {
      this.apiService.endSession(this.sessionId, this.totalSessionSeconds).subscribe({
        next: () => {
          console.log('Session ended successfully:', this.sessionId, this.totalSessionSeconds);
          navigate();
        },
        error: (err) => {
          console.warn('Session end failed:', err);
          navigate();
        }
      });
    } else {
      if (!this.sessionId) console.warn('No session_id to end');
      navigate();
    }
  }

  loadQuestions(schein: string, kategorie: string, unterkategorie?: string, filter?: string) {
    this.loading.set(true);
    this.error.set(null);
    this.apiService.getQuestions(schein, kategorie).subscribe({
      next: (data) => {
        // Filter by unterkategorie if provided
        let filteredQuestions = data;
        if (unterkategorie) {
          filteredQuestions = data.filter(q => q.unterkategorie === unterkategorie);
        }

        // Apply filter if provided (for logged-in users)
        if (filter && this.authService.getToken()) {
          this.applyFilter(filteredQuestions, filter);
        } else {
          this.continueLoadingQuestions(filteredQuestions);
        }
      },
      error: (err) => {
        console.error('Fehler beim Laden der Fragen:', err);
        this.error.set('Fehler beim Laden der Fragen');
        this.loading.set(false);
      }
    });
  }

  private applyFilter(questions: Question[], filter: string) {
    // Lade Fortschrittsdaten
    this.apiService.getQuestionProgress().subscribe({
      next: (response: any) => {
        const progressMap = new Map<number, QuestionProgress>();
        if (response.fortschritte) {
          response.fortschritte.forEach((p: QuestionProgress) => {
            progressMap.set(p.frage_id, p);
          });
        }

        let filteredQuestions = questions;

        if (filter === 'incorrect') {
          // Nur falsch beantwortete Fragen
          filteredQuestions = questions.filter(q => {
            const progress = progressMap.get(q.frage_id);
            return progress && progress.zuletzt_richtig === false;
          });
        } else if (filter === 'bookmarked') {
          // Nur gemerkte Fragen
          filteredQuestions = questions.filter(q => {
            const progress = progressMap.get(q.frage_id);
            return progress && progress.ist_gemerkt === true;
          });
        }

        if (filteredQuestions.length === 0) {
          this.error.set('Keine Fragen gefunden f체r diesen Filter');
          this.loading.set(false);
        } else {
          this.continueLoadingQuestions(filteredQuestions);
        }
      },
      error: (err) => {
        console.error('Fehler beim Laden des Fortschritts:', err);
        this.continueLoadingQuestions(questions); // Fallback: alle Fragen anzeigen
      }
    });
  }

  private continueLoadingQuestions(filteredQuestions: Question[]) {
    // Check user setting for random question order
    const currentUser = this.authService.getCurrentUser();
    const randomOrder = currentUser?.settings?.random_question_order || false;

        if (randomOrder) {
          filteredQuestions = this.shuffleArray(filteredQuestions);
        }

        this.questions.set(filteredQuestions);
        this.currentQuestionIndex.set(0);

        // Shuffle answers for each question
        const shuffledMap = new Map<number, any[]>();
        filteredQuestions.forEach(q => {
          if (q.antworten && q.antworten.length > 0) {
            shuffledMap.set(q.frage_id, this.shuffleArray(q.antworten));
          }
        });
        this.shuffledAnswers.set(shuffledMap);

        // initialize session timers
        this.sessionStart = Date.now();
        this.questionStart = Date.now();
        this.totalSessionSeconds = 0;
        this.answeredCount = 0;
        this.sessionId = null;

        // Try to create a session record on the backend (best-effort).
        // Expecting backend to accept POST /progress/session/ { action: 'start' } -> { session_id }
        const payload: any = {
          user_id: currentUser ? currentUser.id : null,
          session_type: 'kategorie',
          schein_filter: this.schein(),
          kategorie_filter: this.kategorie()
        };

        this.apiService.createSession(payload).subscribe({
          next: (resp) => {
            try {
              if (resp && (resp.session_id || resp.sessionId || resp.id)) {
                this.sessionId = resp.session_id || resp.sessionId || resp.id;
                console.log('Session started, id=', this.sessionId);
              } else {
                console.log('Session create response (no id):', resp);
              }
            } catch (e) {
              console.warn('Unable to parse session create response:', resp);
            }
          },
          error: (err) => {
            console.warn('Session create failed (may be unsupported):', err);
          }
        });

        // Lade Bookmarks f체r eingeloggte Benutzer
        if (this.authService.getToken()) {
          this.loadBookmarks();
        }

        this.loading.set(false);
      },
      error: (err) => {
        console.error('Fehler beim Laden der Fragen:', err);
        this.error.set('Fehler beim Laden der Fragen');
        this.loading.set(false);
      }
    });
  }

  selectAnswer(answer: string) {
    const question = this.currentQuestion();
    if (question) {
      const newMap = new Map(this.selectedAnswers());
      newMap.set(question.frage_id, answer);
      this.selectedAnswers.set(newMap);
    }
  }

  nextQuestion() {
    const index = this.currentQuestionIndex();
    if (index < this.questions().length - 1) {
      this.currentQuestionIndex.set(index + 1);
      this.revealed.set(false);
      // reset question timer for the new question
      this.questionStart = Date.now();
      // Scroll to top
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }

  previousQuestion() {
    const index = this.currentQuestionIndex();
    if (index > 0) {
      this.currentQuestionIndex.set(index - 1);
      this.revealed.set(false);
      // reset question timer when navigating
      this.questionStart = Date.now();
      // Scroll to top
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }

  goToQuestion(index: number) {
    if (index >= 0 && index < this.questions().length) {
      this.currentQuestionIndex.set(index);
      // reset question timer when jumping
      this.questionStart = Date.now();
    }
  }

  submitAnswer() {
    const question = this.currentQuestion();
    const selectedAnswers = this.selectedAnswers();

    if (!question || !selectedAnswers.has(question.frage_id)) {
      alert('Bitte w채hlen Sie eine Antwort aus');
      return;
    }

    const selectedAnswer = selectedAnswers.get(question.frage_id);
    const now = Date.now();
    let timeTakenSeconds = Math.round((now - this.questionStart) / 1000);
    if (timeTakenSeconds <= 0) timeTakenSeconds = 1;

    const request: SubmitAnswerRequest = {
      frage_id: question.frage_id,
      selected_answer: selectedAnswer!,
      time_taken_seconds: timeTakenSeconds
    };

    const token = this.authService.getToken();
    const isGuest = !token;

    // Gast-Modus: Lokale Validierung ohne Backend
    if (isGuest) {
      const isCorrect = selectedAnswer === question.korrekte_antwort;

      // Speichere Ergebnis lokal
      const currentResults = this.answerResults();
      currentResults.push({
        frage_id: question.frage_id,
        frage_text: question.frage_text,
        selected_answer: selectedAnswer!,
        correct_answer: question.korrekte_antwort,
        is_correct: isCorrect
      });
      this.answerResults.set(currentResults);

      console.log('answerResults nach submit (Gast-Modus):', this.answerResults().length, 'von', this.questions().length);

      // Track if answer was incorrect
      if (!isCorrect && question) {
        const newIncorrect = new Set(this.incorrectAnswers());
        newIncorrect.add(question.frage_id);
        this.incorrectAnswers.set(newIncorrect);
      }

      this.totalSessionSeconds += timeTakenSeconds;
      this.answeredCount++;

      const totalQuestions = this.questions().length;
      const allAnswered = this.answeredCount >= totalQuestions;

      if (allAnswered) {
        console.log('All questions answered (Gast-Modus). Navigating to results.');
        this.showResults();
      } else {
        this.nextQuestion();
      }

      return;
    }

    // Angemeldeter Benutzer: Backend-Validierung
    this.apiService.submitAnswer(request).subscribe({
      next: (response) => {
        console.log('Antwort eingereicht:', response);

        // Speichere Fragenfortschritt (richtig/falsch)
        this.apiService.saveQuestionProgress({
          frage_id: question.frage_id,
          ist_richtig: response.is_correct
        }).subscribe({
          next: () => console.log('Fortschritt gespeichert'),
          error: (err) => console.warn('Fortschritt konnte nicht gespeichert werden:', err)
        });

        // Speichere Ergebnis
        const currentResults = this.answerResults();
        currentResults.push({
          frage_id: question.frage_id,
          frage_text: question.frage_text,
          selected_answer: selectedAnswer!,
          correct_answer: response.korrekte_antwort || question.korrekte_antwort,
          is_correct: response.is_correct
        });
        this.answerResults.set(currentResults);

        console.log('answerResults nach submit:', this.answerResults().length, 'von', this.questions().length);

        // Track if answer was incorrect
        if (response.is_correct === false && question) {
          const newIncorrect = new Set(this.incorrectAnswers());
          newIncorrect.add(question.frage_id);
          this.incorrectAnswers.set(newIncorrect);
        } else if (response.is_correct === true && question) {
          // Remove from incorrect if it was there and now correct
          const newIncorrect = new Set(this.incorrectAnswers());
          newIncorrect.delete(question.frage_id);
          this.incorrectAnswers.set(newIncorrect);
        }

        // accumulate session seconds and move to next
        this.totalSessionSeconds += timeTakenSeconds;
        this.answeredCount++;

        const totalQuestions = this.questions().length;
        const allAnswered = this.answeredCount >= totalQuestions;

        if (allAnswered) {
          console.log('All questions answered. Navigating to results.');
          this.showResults();
        } else {
          this.nextQuestion();
        }
      },
      error: (err) => {
        console.error('Fehler beim Einreichen der Antwort:', err);
        const errorMsg = err.error?.message || err.message || 'Fehler beim Einreichen der Antwort';
        alert(`Fehler: ${errorMsg}`);
      }
    });
  }

  getAnswerStatus(answerId: string): string {
    const question = this.currentQuestion();
    if (!question) return '';

    const selectedAnswers = this.selectedAnswers();
    const selected = selectedAnswers.get(question.frage_id);

    if (selected === answerId) {
      return 'selected';
    }
    return '';
  }

  isIncorrectAnswer(questionId: number): boolean {
    return this.incorrectAnswers().has(questionId);
  }

  toggleHint(): void {
    this.showHint.update(v => !v);
  }

  revealAnswer(): void {
    const question = this.currentQuestion();
    if (!question || this.revealed()) return;

    this.revealed.set(true);

    // Als falsch werten (wie gew체nscht)
    const now = Date.now();
    let timeTakenSeconds = Math.round((now - this.questionStart) / 1000);
    if (timeTakenSeconds <= 0) timeTakenSeconds = 1;

    // Finde die richtige Antwort (ist_korrekt ist eine Zahl: 1 = richtig)
    const correctAnswer = question.antworten.find(a => a.ist_korrekt === 1);
    if (correctAnswer) {
      const token = this.authService.getToken();
      const isGuest = !token;

      // Gast-Modus: Lokal speichern
      if (isGuest) {
        // Speichere Ergebnis
        const currentResults = this.answerResults();
        currentResults.push({
          frage_id: question.frage_id,
          frage_text: question.frage_text,
          selected_answer: 'Aufgedeckt',
          correct_answer: question.korrekte_antwort,
          is_correct: false
        });
        this.answerResults.set(currentResults);

        // Als falsch markieren
        const newIncorrect = new Set(this.incorrectAnswers());
        newIncorrect.add(question.frage_id);
        this.incorrectAnswers.set(newIncorrect);

        this.totalSessionSeconds += timeTakenSeconds;
        this.answeredCount++;
        return;
      }

      // Angemeldeter Benutzer: Backend
      const request: SubmitAnswerRequest = {
        frage_id: question.frage_id,
        selected_answer: correctAnswer.buchstabe,
        time_taken_seconds: timeTakenSeconds
      };

      this.apiService.submitAnswer(request).subscribe({
        next: (response) => {
          console.log('Antwort als falsch gewertet:', response);

          // Speichere Ergebnis
          const currentResults = this.answerResults();
          currentResults.push({
            frage_id: question.frage_id,
            frage_text: question.frage_text,
            selected_answer: 'Aufgedeckt',
            correct_answer: response.korrekte_antwort || question.korrekte_antwort,
            is_correct: false
          });
          this.answerResults.set(currentResults);

          // Als falsch markieren
          const newIncorrect = new Set(this.incorrectAnswers());
          newIncorrect.add(question.frage_id);
          this.incorrectAnswers.set(newIncorrect);

          this.totalSessionSeconds += timeTakenSeconds;
          this.answeredCount++;
        },
        error: (err) => {
          console.error('Fehler beim Aufdecken:', err);
        }
      });
    }
  }

  showResults() {
    console.log('showResults called');
    console.log('answerResults:', this.answerResults());
    console.log('schein:', this.schein());
    console.log('kategorie:', this.kategorie());

    this.router.navigate(['/learning/result'], {
      state: {
        results: this.answerResults(),
        schein: this.schein(),
        kategorie: this.kategorie(),
        unterkategorie: this.unterkategorie()
      }
    });
  }

  goToRegister() {
    this.router.navigate(['/register']);
  }

  toggleBookmark() {
    const question = this.currentQuestion();
    if (!question) return;

    const token = this.authService.getToken();
    if (!token) {
      alert('Bitte melden Sie sich an, um Fragen zu merken');
      return;
    }

    const bookmarked = this.bookmarkedQuestions();
    const isCurrentlyBookmarked = bookmarked.has(question.frage_id);
    const newBookmarkedState = !isCurrentlyBookmarked;

    // Optimistisches Update
    const newSet = new Set(bookmarked);
    if (newBookmarkedState) {
      newSet.add(question.frage_id);
    } else {
      newSet.delete(question.frage_id);
    }
    this.bookmarkedQuestions.set(newSet);

    // Backend speichern
    this.apiService.toggleBookmark(question.frage_id, newBookmarkedState).subscribe({
      next: () => {
        console.log('Bookmark gespeichert:', question.frage_id, newBookmarkedState);
      },
      error: (err) => {
        console.error('Fehler beim Speichern des Bookmarks:', err);
        // Rollback bei Fehler
        this.bookmarkedQuestions.set(bookmarked);
        alert('Fehler beim Speichern der Markierung');
      }
    });
  }

  isBookmarked(): boolean {
    const question = this.currentQuestion();
    if (!question) return false;
    return this.bookmarkedQuestions().has(question.frage_id);
  }

  private loadBookmarks() {
    this.apiService.getQuestionProgress().subscribe({
      next: (response: any) => {
        if (response.fortschritte) {
          const bookmarked = new Set<number>();
          response.fortschritte.forEach((progress: QuestionProgress) => {
            if (progress.ist_gemerkt) {
              bookmarked.add(progress.frage_id);
            }
          });
          this.bookmarkedQuestions.set(bookmarked);
        }
      },
      error: (err) => {
        console.error('Fehler beim Laden der Bookmarks:', err);
      }
    });
  }

  private shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
}
